From f634be474cd4914bee32758f03775f5f04227b78 Mon Sep 17 00:00:00 2001
From: Taegil Bae <esrevinu@gmail.com>
Date: Thu, 12 Dec 2013 14:59:31 +0900
Subject: [PATCH 06/13] SoftButtonAreas is replaced by new three options

---
 src/synaptics.c               | 209 +++++++++++++++++-------------------------
 src/synapticsstr.h            |   2 +-
 3 files changed, 95 insertions(+), 129 deletions(-)

diff --git a/src/synaptics.c b/src/synaptics.c
index 26aeaf2..21cb841 100644
--- a/src/synaptics.c
+++ b/src/synaptics.c
@@ -372,88 +372,17 @@ set_percent_option(pointer options, const char *optname,
 Bool
 SynapticsIsSoftButtonAreasValid(int *values)
 {
-    Bool right_disabled = FALSE;
-    Bool middle_disabled = FALSE;
-
     enum {
-        /* right button left, right, top, bottom */
-        RBL = 0,
-        RBR = 1,
-        RBT = 2,
-        RBB = 3,
-        /* middle button left, right, top, bottom */
-        MBL = 4,
-        MBR = 5,
-        MBT = 6,
-        MBB = 7,
+        BL = 0,
+        BR = 1,
+        BT = 2,
+        BB = 3,
     };
 
-    /* Check right button area */
-    if ((((values[RBL] != 0) && (values[RBR] != 0)) && (values[RBL] > values[RBR])) ||
-        (((values[RBT] != 0) && (values[RBB] != 0)) && (values[RBT] > values[RBB])))
-        return FALSE;
-
-    /* Check middle button area */
-    if ((((values[MBL] != 0) && (values[MBR] != 0)) && (values[MBL] > values[MBR])) ||
-        (((values[MBT] != 0) && (values[MBB] != 0)) && (values[MBT] > values[MBB])))
-        return FALSE;
-
-    if (values[RBL] == 0 && values[RBR] == 0 && values[RBT] == 0 && values[RBB] == 0)
-        right_disabled = TRUE;
-
-    if (values[MBL] == 0 && values[MBR] == 0 && values[MBT] == 0 && values[MBB] == 0)
-        middle_disabled = TRUE;
-
-    if (!right_disabled &&
-        ((values[RBL] && values[RBL] == values[RBR]) ||
-         (values[RBT] && values[RBT] == values[RBB])))
-        return FALSE;
-
-    if (!middle_disabled &&
-        ((values[MBL] && values[MBL] == values[MBR]) ||
-         (values[MBT] && values[MBT] == values[MBB])))
+    if ((values[BL] != 0 && values[BR] != 0 && values[BL] > values[BR]) ||
+        (values[BT] != 0 && values[BB] != 0 && values[BT] > values[BB]))
         return FALSE;
 
-    /* Check for overlapping button areas */
-    if (!right_disabled && !middle_disabled) {
-        int right_left = values[RBL] ? values[RBL] : INT_MIN;
-        int right_right = values[RBR] ? values[RBR] : INT_MAX;
-        int right_top = values[RBT] ? values[RBT] : INT_MIN;
-        int right_bottom = values[RBB] ? values[RBB] : INT_MAX;
-        int middle_left = values[MBL] ? values[MBL] : INT_MIN;
-        int middle_right = values[MBR] ? values[MBR] : INT_MAX;
-        int middle_top = values[MBT] ? values[MBT] : INT_MIN;
-        int middle_bottom = values[MBB] ? values[MBB] : INT_MAX;
-
-        /* If areas overlap in the Y axis */
-        if ((right_bottom <= middle_bottom && right_bottom >= middle_top) ||
-            (right_top <= middle_bottom && right_top >= middle_top)) {
-            /* Check for overlapping left edges */
-            if ((right_left < middle_left && right_right > middle_left) ||
-                (middle_left < right_left && middle_right > right_left))
-                return FALSE;
-
-            /* Check for overlapping right edges */
-            if ((right_right > middle_right && right_left < middle_right) ||
-                (middle_right > right_right && middle_left < right_right))
-                return FALSE;
-        }
-
-        /* If areas overlap in the X axis */
-        if ((right_left >= middle_left && right_left <= middle_right) ||
-            (right_right >= middle_left && right_right <= middle_right)) {
-            /* Check for overlapping top edges */
-            if ((right_top < middle_top && right_bottom > middle_top) ||
-                (middle_top < right_top && middle_bottom > right_top))
-                return FALSE;
-
-            /* Check for overlapping bottom edges */
-            if ((right_bottom > middle_bottom && right_top < middle_bottom) ||
-                (middle_bottom > right_bottom && middle_top < right_bottom))
-                return FALSE;
-        }
-    }
-
     return TRUE;
 }
 
@@ -462,74 +391,95 @@ set_softbutton_areas_option(InputInfoPtr pInfo)
 {
     SynapticsPrivate *priv = pInfo->private;
     SynapticsParameters *pars = &priv->synpara;
-    int values[8];
+    int values[3][4];
     int in_percent = 0;         /* bitmask for which ones are in % */
-    char *option_string;
+    char *lrm_string[3];
     char *next_num;
     char *end_str;
-    int i;
+    int i, lrm;
     int width, height;
+    char *option_name[3] = {
+        "SoftLeftButtonArea",
+        "SoftRightButtonArea",
+        "SoftMiddleButtonArea"
+    };
+        
 
     if (!pars->clickpad)
         return;
 
-    option_string = xf86SetStrOption(pInfo->options, "SoftButtonAreas", NULL);
-    if (!option_string)
+    for (lrm = 0; lrm < 3; lrm++)
+        lrm_string[lrm] = xf86SetStrOption(pInfo->options,
+                                           option_name[lrm], NULL);
+
+    if (!lrm_string[0] && !lrm_string[1] && !lrm_string[2])
         return;
 
-    next_num = option_string;
+    for (lrm = 0; lrm < 3; lrm++) {
+        if (lrm_string[lrm] == NULL) continue;
 
-    for (i = 0; i < 8 && *next_num != '\0'; i++) {
-        long int value = strtol(next_num, &end_str, 0);
+        next_num = lrm_string[lrm];
 
-        if (value > INT_MAX || value < -INT_MAX)
-            goto fail;
+        in_percent = 0;
+        for (i = 0; i < 4 && *next_num != '\0'; i++) {
+            long int value = strtol(next_num, &end_str, 0);
+
+            if (value > INT_MAX || value < -INT_MAX)
+                goto fail;
 
-        values[i] = value;
+            values[lrm][i] = value;
 
-        if (next_num != end_str) {
-            if (end_str && *end_str == '%') {
-                in_percent |= 1 << i;
-                end_str++;
+            if (next_num != end_str) {
+                if (end_str && *end_str == '%') {
+                    in_percent |= 1 << i;
+                    end_str++;
+                }
+                next_num = end_str;
             }
-            next_num = end_str;
+            else
+                goto fail;
         }
-        else
+
+        if (i < 4 || *next_num != '\0')
             goto fail;
-    }
 
-    if (i < 8 || *next_num != '\0')
-        goto fail;
+        width = priv->maxx - priv->minx;
+        height = priv->maxy - priv->miny;
 
-    width = priv->maxx - priv->minx;
-    height = priv->maxy - priv->miny;
+        for (i = 0; in_percent && i < 4; i++) {
+            int base, size;
 
-    for (i = 0; in_percent && i < 8; i++) {
-        int base, size;
+            if ((in_percent & (1 << i)) == 0 || values[lrm][i] == 0)
+                continue;
 
-        if ((in_percent & (1 << i)) == 0 || values[i] == 0)
-            continue;
+            size = ((i % 4) < 2) ? width : height;
+            base = ((i % 4) < 2) ? priv->minx : priv->miny;
+            values[lrm][i] = base + size * values[lrm][i] / 100.0;
+        }
 
-        size = ((i % 4) < 2) ? width : height;
-        base = ((i % 4) < 2) ? priv->minx : priv->miny;
-        values[i] = base + size * values[i] / 100.0;
-    }
+        if (!SynapticsIsSoftButtonAreasValid(values[lrm]))
+            goto fail;
 
-    if (!SynapticsIsSoftButtonAreasValid(values))
-        goto fail;
+        memcpy(pars->softbutton_areas[lrm], values[lrm], 4 * sizeof(int));
+    }
 
-    memcpy(pars->softbutton_areas[0], values, 4 * sizeof(int));
-    memcpy(pars->softbutton_areas[1], values + 4, 4 * sizeof(int));
 
-    free(option_string);
+    for (lrm = 0; lrm < 3; lrm++) {
+        if (lrm_string[lrm])
+            free(lrm_string[lrm]);
+    }
 
     return;
 
  fail:
     xf86IDrvMsg(pInfo, X_ERROR,
-                "invalid SoftButtonAreas value '%s', keeping defaults\n",
-                option_string);
-    free(option_string);
+                "invalid %s value '%s', keeping defaults\n",
+                option_name[lrm], lrm_string[lrm]);
+
+    for (lrm = 0; lrm < 3; lrm++) {
+        if (lrm_string[lrm])
+            free(lrm_string[lrm]);
+    }
 }
 
 static void
@@ -1396,7 +1346,8 @@ is_inside_button_area(SynapticsParameters * para, int which, int x, int y)
         BOTTOM = 3
     };
 
-    if (para->softbutton_areas[which][LEFT] == 0 &&
+    if (which != 0 &&  /* if not left button */
+        para->softbutton_areas[which][LEFT] == 0 &&
         para->softbutton_areas[which][RIGHT] == 0 &&
         para->softbutton_areas[which][TOP] == 0 &&
         para->softbutton_areas[which][BOTTOM] == 0)
@@ -1419,17 +1370,23 @@ is_inside_button_area(SynapticsParameters * para, int which, int x, int y)
 }
 
 static Bool
-is_inside_rightbutton_area(SynapticsParameters * para, int x, int y)
+is_inside_leftbutton_area(SynapticsParameters * para, int x, int y)
 {
     return is_inside_button_area(para, 0, x, y);
 }
 
 static Bool
-is_inside_middlebutton_area(SynapticsParameters * para, int x, int y)
+is_inside_rightbutton_area(SynapticsParameters * para, int x, int y)
 {
     return is_inside_button_area(para, 1, x, y);
 }
 
+static Bool
+is_inside_middlebutton_area(SynapticsParameters * para, int x, int y)
+{
+    return is_inside_button_area(para, 2, x, y);
+}
+
 static CARD32
 timerFunc(OsTimerPtr timer, CARD32 now, pointer arg)
 {
@@ -2582,12 +2539,7 @@ update_hw_button_state(const InputInfoPtr pInfo, struct SynapticsHwState *hw,
         if (!old->left && !old->right && !old->middle &&
             (hw->left || hw->z > para->finger_press) &&
             !hw->right && !hw->middle && !hw->trackpoint_middle) {
-            hw->left = 1;
-            if (is_inside_rightbutton_area(para, hw->x, hw->y)) {
-                hw->left = 0;
-                hw->right = 1;
-            }
-            else if (is_inside_middlebutton_area(para, hw->x, hw->y)) {
+            if (is_inside_middlebutton_area(para, hw->x, hw->y)) {
                 hw->left = 0;
                 hw->middle = 1;
                 if (trackpoint) {
@@ -2595,6 +2547,14 @@ update_hw_button_state(const InputInfoPtr pInfo, struct SynapticsHwState *hw,
                     hw->trackpoint_middle = 1;
                     EvdevWheelEmuFilterButton(trackpoint, 2, 1);
                 }
+            } else if (is_inside_rightbutton_area(para, hw->x, hw->y)) {
+                hw->left = 0;
+                hw->right = 1;
+            } else if (hw->left ||
+                       is_inside_leftbutton_area(para, hw->x, hw->y)) {
+                hw->left = 1;
+            } else {
+                hw->left = 0;
             }
         }
         else if (hw->left || hw->z > para->finger_press / 2) {
@@ -2781,7 +2741,6 @@ filter_jitter(SynapticsPrivate * priv, int *x, int *y)
 static void
 reset_hw_state(struct SynapticsHwState *hw)
 {
-    hw->left = 0;
     hw->x = 0;
     hw->y = 0;
     hw->z = 0;
diff --git a/src/synapticsstr.h b/src/synapticsstr.h
index 696a4f0..a987399 100644
--- a/src/synapticsstr.h
+++ b/src/synapticsstr.h
@@ -186,7 +186,7 @@ typedef struct _SynapticsParameters {
     unsigned int resolution_horiz;      /* horizontal resolution of touchpad in units/mm */
     unsigned int resolution_vert;       /* vertical resolution of touchpad in units/mm */
     int area_left_edge, area_right_edge, area_top_edge, area_bottom_edge;       /* area coordinates absolute */
-    int softbutton_areas[2][4]; /* soft button area coordinates, 0 => right, 1 => middle button */
+    int softbutton_areas[3][4]; /* soft button area coordinates, 0 => left, 1 => right, 2 => middle button */
     int hyst_x, hyst_y;         /* x and y width of hysteresis box */
 } SynapticsParameters;
 
-- 
1.9.0

